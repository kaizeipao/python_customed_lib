class tracer:
	"""creat a class decorater that count the call number of func """
	def __init__(self, func):
	"""initialize instance self attr which wrap the original func,defined call number"""
		self.calls = 0
		self.func = func
		
	def __call__(self,*args):
		"""intercept the call attr, count accumulated call number,
		then return the instance func（the packed original func）"""
		self.calls += 1
		self.func(*args)
		print('call %s to %s' %(self.calls, self.func.__name__))
		
		
"""the original wraped func"""		
@tracer
def func(*args):
	pass
	

"""But when decorating a class, then a question come:
   the wraped class have an instance 'self', and the tracer have an instance 'self' too,
   in fact, only the tracer's instance pass through the wraped class.
   to slove this problem, use the nested def to bulid a decorator"""
   
def tracer(func):
	calls = 0                                                 #calls become a func.attr
	def onCall(*args, **kwargs):
		nonlocal calls                                        #nested func can use nest func.attr                                       
		onCall.calls += 1
		print('calls %s to %s' %(onCall.calls, func.__name__))
		return func(*args, **kwargs)
	return onCall
 
 
 @tracer
 def func():
 	pass
